// Package hash provides hash functions compatible with Orochi DB's sharding algorithm.
//
// This package implements the exact CRC32-based hash algorithm used by Orochi DB
// for shard routing. It ensures that queries routed through PgDog will hash
// distribution column values identically to how Orochi DB hashes them internally.
//
// The hash algorithm uses:
//   - CRC32 with IEEE polynomial 0xEDB88320
//   - Initial value: 0xFFFFFFFF
//   - Final XOR: 0xFFFFFFFF
//   - Type-specific byte serialization matching PostgreSQL's internal representation
package hash

import (
	"encoding/binary"
	"hash/crc32"
	"math"

	"github.com/google/uuid"
)

// Constants matching Orochi DB's distribution.h
const (
	// OrochiHashSeed is defined in Orochi's distribution.h but not currently used
	// in the CRC32 implementation. Kept for reference and future compatibility.
	OrochiHashSeed = 0x9747b28c

	// OrochiHashModulus is the modulus used for hash distribution
	OrochiHashModulus = math.MaxInt32
)

// crc32Table is the IEEE CRC32 lookup table with polynomial 0xEDB88320
// This matches the table generated by init_crc32_table() in distribution.c
var crc32Table = crc32.MakeTable(crc32.IEEE)

// OrochiHash computes a CRC32 hash of the given data using the exact algorithm
// implemented in Orochi DB's orochi_crc32_hash() function.
//
// The algorithm:
//  1. Initialize CRC to 0xFFFFFFFF
//  2. Process each byte through the CRC32 lookup table
//  3. XOR final result with 0xFFFFFFFF
func OrochiHash(data []byte) uint32 {
	// crc32.Checksum already implements the standard CRC32 algorithm:
	// - Initial value 0xFFFFFFFF
	// - Final XOR with 0xFFFFFFFF
	// This matches orochi_crc32_hash() exactly
	return crc32.Checksum(data, crc32Table)
}

// HashInt16 computes the Orochi hash for a 16-bit integer value.
// Matches orochi_hash_datum() for INT2OID.
func HashInt16(value int16) int32 {
	buf := make([]byte, 2)
	binary.LittleEndian.PutUint16(buf, uint16(value))
	return int32(OrochiHash(buf))
}

// HashInt32 computes the Orochi hash for a 32-bit integer value.
// Matches orochi_hash_datum() for INT4OID.
func HashInt32(value int32) int32 {
	buf := make([]byte, 4)
	binary.LittleEndian.PutUint32(buf, uint32(value))
	return int32(OrochiHash(buf))
}

// HashInt64 computes the Orochi hash for a 64-bit integer value.
// Matches orochi_hash_datum() for INT8OID.
func HashInt64(value int64) int32 {
	buf := make([]byte, 8)
	binary.LittleEndian.PutUint64(buf, uint64(value))
	return int32(OrochiHash(buf))
}

// HashText computes the Orochi hash for a text/varchar value.
// Matches orochi_hash_datum() for TEXTOID and VARCHAROID.
// The hash is computed on the raw UTF-8 bytes of the string.
func HashText(value string) int32 {
	return int32(OrochiHash([]byte(value)))
}

// HashUUID computes the Orochi hash for a UUID value.
// Matches orochi_hash_datum() for UUIDOID.
// UUIDs are hashed as their raw 16-byte representation.
func HashUUID(value uuid.UUID) int32 {
	return int32(OrochiHash(value[:]))
}

// HashUUIDString parses a UUID string and computes its Orochi hash.
// Returns an error if the string is not a valid UUID.
func HashUUIDString(value string) (int32, error) {
	u, err := uuid.Parse(value)
	if err != nil {
		return 0, err
	}
	return HashUUID(u), nil
}

// HashBytes computes the Orochi hash for raw byte data.
// This is the most general form and can be used for any data type.
func HashBytes(data []byte) int32 {
	return int32(OrochiHash(data))
}

// GetShardIndex calculates which shard a hash value belongs to.
// This matches orochi_get_shard_index() in distribution.c.
//
// The calculation uses unsigned modulo to ensure consistent results
// regardless of whether the hash value is positive or negative.
func GetShardIndex(hashValue int32, shardCount int32) int32 {
	if shardCount <= 0 {
		return 0
	}
	// Convert to unsigned for proper modulo operation
	// This matches the C code: (uint32)hash_value % (uint32)shard_count
	unsignedHash := uint32(hashValue)
	return int32(unsignedHash % uint32(shardCount))
}

// GetShardIndexForInt32 is a convenience function that computes the hash
// and shard index for an int32 value in one call.
func GetShardIndexForInt32(value int32, shardCount int32) int32 {
	return GetShardIndex(HashInt32(value), shardCount)
}

// GetShardIndexForInt64 is a convenience function that computes the hash
// and shard index for an int64 value in one call.
func GetShardIndexForInt64(value int64, shardCount int32) int32 {
	return GetShardIndex(HashInt64(value), shardCount)
}

// GetShardIndexForText is a convenience function that computes the hash
// and shard index for a text value in one call.
func GetShardIndexForText(value string, shardCount int32) int32 {
	return GetShardIndex(HashText(value), shardCount)
}

// GetShardIndexForUUID is a convenience function that computes the hash
// and shard index for a UUID value in one call.
func GetShardIndexForUUID(value uuid.UUID, shardCount int32) int32 {
	return GetShardIndex(HashUUID(value), shardCount)
}

// HashValue is a generic interface for computing Orochi-compatible hashes.
// It dispatches to the appropriate type-specific hash function based on
// the concrete type of the value.
//
// Supported types:
//   - int16, int32, int64, int
//   - uint16, uint32, uint64, uint
//   - string
//   - []byte
//   - uuid.UUID
//
// For unsupported types, it returns 0 and false.
func HashValue(value interface{}) (int32, bool) {
	switch v := value.(type) {
	case int16:
		return HashInt16(v), true
	case int32:
		return HashInt32(v), true
	case int64:
		return HashInt64(v), true
	case int:
		return HashInt64(int64(v)), true
	case uint16:
		return HashInt16(int16(v)), true
	case uint32:
		return HashInt32(int32(v)), true
	case uint64:
		return HashInt64(int64(v)), true
	case uint:
		return HashInt64(int64(v)), true
	case string:
		return HashText(v), true
	case []byte:
		return HashBytes(v), true
	case uuid.UUID:
		return HashUUID(v), true
	default:
		return 0, false
	}
}

// Router provides shard routing functionality for PgDog integration.
// It maintains the shard count and provides methods to route values to shards.
type Router struct {
	shardCount int32
}

// NewRouter creates a new Router with the specified shard count.
func NewRouter(shardCount int32) *Router {
	return &Router{shardCount: shardCount}
}

// ShardCount returns the number of shards configured for this router.
func (r *Router) ShardCount() int32 {
	return r.shardCount
}

// RouteInt32 returns the shard index for an int32 distribution value.
func (r *Router) RouteInt32(value int32) int32 {
	return GetShardIndexForInt32(value, r.shardCount)
}

// RouteInt64 returns the shard index for an int64 distribution value.
func (r *Router) RouteInt64(value int64) int32 {
	return GetShardIndexForInt64(value, r.shardCount)
}

// RouteText returns the shard index for a text distribution value.
func (r *Router) RouteText(value string) int32 {
	return GetShardIndexForText(value, r.shardCount)
}

// RouteUUID returns the shard index for a UUID distribution value.
func (r *Router) RouteUUID(value uuid.UUID) int32 {
	return GetShardIndexForUUID(value, r.shardCount)
}

// Route returns the shard index for any supported distribution value.
// Returns -1 if the value type is not supported.
func (r *Router) Route(value interface{}) int32 {
	hash, ok := HashValue(value)
	if !ok {
		return -1
	}
	return GetShardIndex(hash, r.shardCount)
}

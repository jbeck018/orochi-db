#!/bin/bash
# ==============================================================================
# PgDog Secrets Deployment Script
# ==============================================================================
#
# Generates real credentials and applies them directly to Kubernetes.
# This script NEVER writes secrets to files tracked by git.
#
# Prerequisites:
#   - kubectl configured with correct context
#   - openssl installed
#   - python3 installed
#   - Access to control-plane secrets (for JWT_SECRET, DB credentials)
#
# Usage:
#   ./deploy-secrets.sh                    # Interactive mode
#   ./deploy-secrets.sh --db-host HOST     # Specify DB host
#   ./deploy-secrets.sh --dry-run          # Preview without applying
#
# ==============================================================================

set -euo pipefail

NAMESPACE="orochi-cloud"
DRY_RUN=false
DB_HOST=""
DB_PORT="25060"
DB_USER=""
DB_PASSWORD=""

# Parse arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        --dry-run) DRY_RUN=true; shift ;;
        --db-host) DB_HOST="$2"; shift 2 ;;
        --db-port) DB_PORT="$2"; shift 2 ;;
        --db-user) DB_USER="$2"; shift 2 ;;
        --db-password) DB_PASSWORD="$2"; shift 2 ;;
        --namespace) NAMESPACE="$2"; shift 2 ;;
        -h|--help)
            echo "Usage: $0 [--dry-run] [--db-host HOST] [--db-port PORT] [--db-user USER] [--db-password PASS] [--namespace NS]"
            exit 0
            ;;
        *) echo "Unknown option: $1"; exit 1 ;;
    esac
done

echo "=== PgDog Secrets Deployment ==="
echo "Namespace: ${NAMESPACE}"
echo "Dry run: ${DRY_RUN}"

# ---------------------------------------------------------------------------
# Step 1: Detect database credentials from existing control-plane secrets
# ---------------------------------------------------------------------------
if [[ -z "${DB_HOST}" ]]; then
    echo ""
    echo "Detecting database credentials from control-plane secrets..."
    DB_HOST=$(kubectl get secret control-plane-secrets -n "${NAMESPACE}" \
        -o jsonpath='{.data.DB_HOST}' | base64 -d 2>/dev/null || echo "")

    if [[ -z "${DB_HOST}" ]]; then
        echo "ERROR: Could not detect DB_HOST. Specify with --db-host"
        exit 1
    fi

    DB_PORT=$(kubectl get secret control-plane-secrets -n "${NAMESPACE}" \
        -o jsonpath='{.data.DB_PORT}' | base64 -d 2>/dev/null || echo "25060")
fi

if [[ -z "${DB_USER}" ]]; then
    DB_USER=$(kubectl get secret control-plane-secrets -n "${NAMESPACE}" \
        -o jsonpath='{.data.DB_USER}' | base64 -d 2>/dev/null || echo "")
    if [[ -z "${DB_USER}" ]]; then
        DB_USER="doadmin"
        echo "WARNING: Could not detect DB_USER, defaulting to 'doadmin'"
    fi
fi

if [[ -z "${DB_PASSWORD}" ]]; then
    DB_PASSWORD=$(kubectl get secret control-plane-secrets -n "${NAMESPACE}" \
        -o jsonpath='{.data.DB_PASSWORD}' | base64 -d 2>/dev/null || echo "")
    if [[ -z "${DB_PASSWORD}" ]]; then
        echo "ERROR: Could not detect DB_PASSWORD from control-plane-secrets."
        echo "Specify with --db-password"
        exit 1
    fi
fi

echo "Database host: ${DB_HOST}:${DB_PORT}"
echo "Database user: ${DB_USER}"

# ---------------------------------------------------------------------------
# Step 2: Get JWT secret from control-plane (for HMAC validation)
# ---------------------------------------------------------------------------
echo ""
echo "Retrieving JWT secret from control-plane..."
JWT_SECRET=$(kubectl get secret control-plane-secrets -n "${NAMESPACE}" \
    -o jsonpath='{.data.JWT_SECRET}' | base64 -d 2>/dev/null || echo "")

if [[ -z "${JWT_SECRET}" ]]; then
    echo "ERROR: Could not retrieve JWT_SECRET from control-plane-secrets"
    exit 1
fi
echo "JWT secret retrieved (length: ${#JWT_SECRET})"

# ---------------------------------------------------------------------------
# Step 3: Generate PgDog users.toml with backend DB credentials
# ---------------------------------------------------------------------------
echo ""
echo "Generating users.toml with backend credentials..."

# Escape password for TOML (double any backslashes, escape quotes)
ESCAPED_DB_PASSWORD=$(echo -n "${DB_PASSWORD}" | sed 's/\\/\\\\/g; s/"/\\"/g')

USERS_TOML=$(cat <<TOML_EOF
# PgDog users.toml - Generated by deploy-secrets.sh
# DO NOT EDIT MANUALLY - re-run deploy-secrets.sh to update

# Main application user (used by jwt-proxy)
[[users]]
name = "orochi_app"
database = "orochi_cloud"
server_user = "${DB_USER}"
server_password = "${ESCAPED_DB_PASSWORD}"
pool_size = 5
pooler_mode = "transaction"

# Admin user
[[users]]
name = "orochi_admin"
database = "orochi_cloud"
server_user = "${DB_USER}"
server_password = "${ESCAPED_DB_PASSWORD}"
pool_size = 3
pooler_mode = "session"

# Read-only user for reporting
[[users]]
name = "orochi_readonly"
database = "orochi_cloud"
server_user = "${DB_USER}"
server_password = "${ESCAPED_DB_PASSWORD}"
pool_size = 5
pooler_mode = "transaction"
read_only = true

# Analytics user with extended timeouts
[[users]]
name = "orochi_analytics"
database = "orochi_cloud"
server_user = "${DB_USER}"
server_password = "${ESCAPED_DB_PASSWORD}"
pool_size = 3
pooler_mode = "transaction"
statement_timeout = 1800000
read_only = true
TOML_EOF
)

echo "users.toml generated for 4 users (backend: ${DB_USER})"

# ---------------------------------------------------------------------------
# Step 4: Generate TLS certificate
# ---------------------------------------------------------------------------
echo ""
echo "Generating self-signed TLS certificate..."

TMPDIR=$(mktemp -d)
trap "rm -rf ${TMPDIR}" EXIT

openssl req -x509 -newkey rsa:2048 \
    -keyout "${TMPDIR}/tls.key" \
    -out "${TMPDIR}/tls.crt" \
    -days 365 -nodes \
    -subj "/CN=pgdog.${NAMESPACE}.svc.cluster.local/O=Orochi DB" \
    -addext "subjectAltName=DNS:pgdog.${NAMESPACE}.svc.cluster.local,DNS:pgdog-internal.${NAMESPACE}.svc.cluster.local,DNS:pgdog-headless.${NAMESPACE}.svc.cluster.local,DNS:*.${NAMESPACE}.svc.cluster.local,DNS:localhost,IP:127.0.0.1" \
    2>/dev/null

echo "TLS certificate generated (valid 365 days)"

# ---------------------------------------------------------------------------
# Step 5: Apply secrets to Kubernetes
# ---------------------------------------------------------------------------
echo ""

if [[ "${DRY_RUN}" == "true" ]]; then
    echo "=== DRY RUN - Would create the following secrets ==="
    echo ""
    echo "Secret: pgdog-secrets"
    echo "  JWT_ISSUER: orochi-cloud"
    echo "  JWT_AUDIENCE: orochi-db"
    echo "  jwt-hmac-secret: (${#JWT_SECRET} chars)"
    echo "  users.toml: (4 users with backend credentials)"
    echo "  PRIMARY_DB_HOST: ${DB_HOST}"
    echo ""
    echo "Secret: pgdog-tls (kubernetes.io/tls)"
    echo "  tls.crt: (self-signed, 365 days)"
    echo "  tls.key: (RSA 2048)"
    echo ""
    echo "To apply, run without --dry-run"
    exit 0
fi

echo "Applying secrets to namespace ${NAMESPACE}..."

# Delete existing secrets (if any)
kubectl delete secret pgdog-secrets -n "${NAMESPACE}" --ignore-not-found 2>/dev/null
kubectl delete secret pgdog-tls -n "${NAMESPACE}" --ignore-not-found 2>/dev/null

# Create pgdog-secrets (includes users.toml with backend credentials)
kubectl create secret generic pgdog-secrets \
    -n "${NAMESPACE}" \
    --from-literal=JWT_ISSUER="orochi-cloud" \
    --from-literal=JWT_AUDIENCE="orochi-db" \
    --from-literal=jwt-hmac-secret="${JWT_SECRET}" \
    --from-literal=PRIMARY_DB_HOST="${DB_HOST}" \
    --from-literal=users.toml="${USERS_TOML}"

# Label it
kubectl label secret pgdog-secrets -n "${NAMESPACE}" \
    app=pgdog \
    app.kubernetes.io/name=pgdog \
    app.kubernetes.io/component=connection-pooler \
    app.kubernetes.io/part-of=orochi-cloud

# Create pgdog-tls
kubectl create secret tls pgdog-tls \
    -n "${NAMESPACE}" \
    --cert="${TMPDIR}/tls.crt" \
    --key="${TMPDIR}/tls.key"

# Label it
kubectl label secret pgdog-tls -n "${NAMESPACE}" \
    app=pgdog \
    app.kubernetes.io/name=pgdog \
    app.kubernetes.io/component=connection-pooler \
    app.kubernetes.io/part-of=orochi-cloud

echo ""
echo "=== Secrets deployed successfully ==="
echo ""
kubectl get secrets -n "${NAMESPACE}" -l app=pgdog

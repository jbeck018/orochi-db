apiVersion: apps/v1
kind: Deployment
metadata:
  name: orochi-autoscaler
  namespace: orochi-system
  labels:
    app.kubernetes.io/name: autoscaler
    app.kubernetes.io/component: autoscaler
    app.kubernetes.io/part-of: orochi-cloud
spec:
  replicas: 2
  selector:
    matchLabels:
      app.kubernetes.io/name: autoscaler
      app.kubernetes.io/component: autoscaler
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1
      maxUnavailable: 0
  template:
    metadata:
      labels:
        app.kubernetes.io/name: autoscaler
        app.kubernetes.io/component: autoscaler
        app.kubernetes.io/part-of: orochi-cloud
      annotations:
        prometheus.io/scrape: "true"
        prometheus.io/port: "9090"
        prometheus.io/path: "/metrics"
    spec:
      serviceAccountName: orochi-autoscaler
      securityContext:
        runAsNonRoot: true
        runAsUser: 1000
        runAsGroup: 1000
        fsGroup: 1000
      containers:
        - name: autoscaler
          image: ghcr.io/orochi-db/autoscaler:latest
          imagePullPolicy: IfNotPresent
          args:
            - --config=/etc/autoscaler/config.yaml
          ports:
            - name: grpc
              containerPort: 50051
              protocol: TCP
            - name: metrics
              containerPort: 9090
              protocol: TCP
            - name: health
              containerPort: 8080
              protocol: TCP
          env:
            - name: KUBERNETES_IN_CLUSTER
              value: "true"
            - name: PROMETHEUS_ADDRESS
              value: "http://prometheus.monitoring.svc.cluster.local:9090"
            - name: LOG_LEVEL
              value: "info"
            - name: LOG_FORMAT
              value: "json"
          resources:
            requests:
              cpu: 100m
              memory: 256Mi
            limits:
              cpu: 500m
              memory: 512Mi
          livenessProbe:
            httpGet:
              path: /healthz
              port: health
            initialDelaySeconds: 10
            periodSeconds: 10
            timeoutSeconds: 5
            failureThreshold: 3
          readinessProbe:
            httpGet:
              path: /readyz
              port: health
            initialDelaySeconds: 5
            periodSeconds: 5
            timeoutSeconds: 3
            failureThreshold: 3
          volumeMounts:
            - name: config
              mountPath: /etc/autoscaler
              readOnly: true
          securityContext:
            allowPrivilegeEscalation: false
            readOnlyRootFilesystem: true
            capabilities:
              drop:
                - ALL
      volumes:
        - name: config
          configMap:
            name: orochi-autoscaler-config
      affinity:
        podAntiAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
            - weight: 100
              podAffinityTerm:
                labelSelector:
                  matchLabels:
                    app.kubernetes.io/name: autoscaler
                topologyKey: kubernetes.io/hostname
      topologySpreadConstraints:
        - maxSkew: 1
          topologyKey: topology.kubernetes.io/zone
          whenUnsatisfiable: ScheduleAnyway
          labelSelector:
            matchLabels:
              app.kubernetes.io/name: autoscaler
---
apiVersion: v1
kind: Service
metadata:
  name: orochi-autoscaler
  namespace: orochi-system
  labels:
    app.kubernetes.io/name: autoscaler
    app.kubernetes.io/component: autoscaler
    app.kubernetes.io/part-of: orochi-cloud
spec:
  type: ClusterIP
  ports:
    - name: grpc
      port: 50051
      targetPort: grpc
      protocol: TCP
    - name: metrics
      port: 9090
      targetPort: metrics
      protocol: TCP
  selector:
    app.kubernetes.io/name: autoscaler
    app.kubernetes.io/component: autoscaler
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: orochi-autoscaler
  namespace: orochi-system
  labels:
    app.kubernetes.io/name: autoscaler
    app.kubernetes.io/component: autoscaler
    app.kubernetes.io/part-of: orochi-cloud
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: orochi-autoscaler
  labels:
    app.kubernetes.io/name: autoscaler
    app.kubernetes.io/component: autoscaler
    app.kubernetes.io/part-of: orochi-cloud
rules:
  # Watch and update StatefulSets and Deployments
  - apiGroups: ["apps"]
    resources: ["statefulsets", "deployments"]
    verbs: ["get", "list", "watch", "update", "patch"]
  - apiGroups: ["apps"]
    resources: ["statefulsets/scale", "deployments/scale"]
    verbs: ["get", "update", "patch"]
  # Watch pods
  - apiGroups: [""]
    resources: ["pods"]
    verbs: ["get", "list", "watch"]
  # Watch services
  - apiGroups: [""]
    resources: ["services"]
    verbs: ["get", "list", "watch"]
  # Watch and update PVCs for storage scaling
  - apiGroups: [""]
    resources: ["persistentvolumeclaims"]
    verbs: ["get", "list", "watch", "update", "patch"]
  # Create events for scaling operations
  - apiGroups: [""]
    resources: ["events"]
    verbs: ["create", "patch"]
  # Watch Orochi CRDs
  - apiGroups: ["orochi.io"]
    resources: ["orochipostgresclusters"]
    verbs: ["get", "list", "watch", "update", "patch"]
  - apiGroups: ["orochi.io"]
    resources: ["orochipostgresclusters/status"]
    verbs: ["get", "update", "patch"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: orochi-autoscaler
  labels:
    app.kubernetes.io/name: autoscaler
    app.kubernetes.io/component: autoscaler
    app.kubernetes.io/part-of: orochi-cloud
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: orochi-autoscaler
subjects:
  - kind: ServiceAccount
    name: orochi-autoscaler
    namespace: orochi-system
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: orochi-autoscaler-config
  namespace: orochi-system
  labels:
    app.kubernetes.io/name: autoscaler
    app.kubernetes.io/component: autoscaler
    app.kubernetes.io/part-of: orochi-cloud
data:
  config.yaml: |
    server:
      grpcPort: 50051
      metricsPort: 9090
      healthPort: 8080
      shutdownTimeout: 30s

    kubernetes:
      inCluster: true
      resyncPeriod: 30s
      qps: 50
      burst: 100
      labelSelector: "app.kubernetes.io/managed-by=orochi-operator"

    prometheus:
      address: "http://prometheus.monitoring.svc.cluster.local:9090"
      timeout: 30s
      metricPrefix: "orochi_"
      scrapeInterval: 15s

    scaling:
      evaluationInterval: 15s
      metricHistoryWindow: 5m
      stabilizationWindow: 3m
      maxConcurrentScaling: 5

      horizontal:
        minReplicas: 1
        maxReplicas: 10
        targetCPUUtilization: 70
        targetMemoryUtilization: 80
        targetConnectionsPerPod: 100
        targetQueryLatencyMs: 100
        scaleUpCooldown: 60s
        scaleDownCooldown: 300s
        scaleUpStep: 2
        scaleDownStep: 1

      vertical:
        minCPU: "250m"
        maxCPU: "8"
        minMemory: "512Mi"
        maxMemory: "32Gi"
        targetCPUUtilization: 70
        targetMemoryUtilization: 80
        cooldown: 600s

    logging:
      level: "info"
      format: "json"
      output: "stdout"
---
apiVersion: policy/v1
kind: PodDisruptionBudget
metadata:
  name: orochi-autoscaler
  namespace: orochi-system
  labels:
    app.kubernetes.io/name: autoscaler
    app.kubernetes.io/component: autoscaler
    app.kubernetes.io/part-of: orochi-cloud
spec:
  minAvailable: 1
  selector:
    matchLabels:
      app.kubernetes.io/name: autoscaler
      app.kubernetes.io/component: autoscaler
